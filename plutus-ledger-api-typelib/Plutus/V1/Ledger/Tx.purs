-- File auto generated by purescript-bridge! --
module Plutus.V1.Ledger.Tx where

import Prelude

import Aeson
  ( Aeson
  , aesonNull
  , class DecodeAeson
  , class EncodeAeson
  , decodeAeson
  , encodeAeson
  )
import Aeson.Decode ((</$\>), (</*\>), (</\>), decode, null)
import Aeson.Encode ((>$<), (>/\<), encode, null)
import Control.Lazy (defer)
import Data.BigInt (BigInt)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe, Maybe(Nothing, Just))
import Data.Newtype (class Newtype, unwrap, wrap)
import Data.Op (Op(Op))
import Data.Show.Generic (genericShow)
import Data.Tuple (Tuple(Tuple))
import Data.Tuple.Nested ((/\))
import FromData (class FromData, genericFromData)
import Plutus.Types.Address (Address)
import Plutus.Types.DataSchema
  ( ApPCons
  , Field
  , I
  , Id
  , IxK
  , MkField
  , MkField_
  , MkIxK
  , MkIxK_
  , PCons
  , PNil
  , PSchema
  , class HasPlutusSchema
  , type (:+)
  , type (:=)
  , type (@@)
  )
import Plutus.Types.Value (Value)
import Plutus.V1.Ledger.Scripts (DatumHash)
import Plutus.V1.Ledger.TxId (TxId)
import ToData (class ToData, genericToData)
import Type.Proxy (Proxy(Proxy))
import TypeLevel.Nat (S, Z)
import Aeson.Decode as D
import Aeson.Encode as E
import Data.Map as Map

newtype TxOut = TxOut
  { txOutAddress :: Address
  , txOutValue :: Value
  , txOutDatumHash :: Maybe DatumHash
  }

derive instance Eq TxOut

instance Show TxOut where
  show a = genericShow a

instance EncodeAeson TxOut where
  encodeAeson' x = pure $
    ( defer \_ -> E.encode $ unwrap >$<
        ( E.record
            { txOutAddress: E.value :: _ Address
            , txOutValue: E.value :: _ Value
            , txOutDatumHash: (E.maybe E.value) :: _ (Maybe DatumHash)
            }
        )
    ) x

instance DecodeAeson TxOut where
  decodeAeson = defer \_ -> D.decode $
    ( TxOut <$> D.record "TxOut"
        { txOutAddress: D.value :: _ Address
        , txOutValue: D.value :: _ Value
        , txOutDatumHash: (D.maybe D.value) :: _ (Maybe DatumHash)
        }
    )

derive instance Generic TxOut _

derive instance Newtype TxOut _

instance
  HasPlutusSchema TxOut
    ( "TxOut"
        :=
          ( "txOutAddress" := I Address
              :+ "txOutValue"
              := I Value
              :+ "txOutDatumHash"
              := I (Maybe DatumHash)
              :+ PNil
          )
        @@ (Z)
        :+ PNil
    )

instance ToData TxOut where
  toData x = genericToData x

instance FromData TxOut where
  fromData x = genericFromData x

--------------------------------------------------------------------------------

_TxOut
  :: Iso' TxOut
       { txOutAddress :: Address
       , txOutValue :: Value
       , txOutDatumHash :: Maybe DatumHash
       }
_TxOut = _Newtype

--------------------------------------------------------------------------------

newtype TxOutRef = TxOutRef
  { txOutRefId :: TxId
  , txOutRefIdx :: BigInt
  }

derive instance Eq TxOutRef

instance Show TxOutRef where
  show a = genericShow a

instance EncodeAeson TxOutRef where
  encodeAeson' x = pure $
    ( defer \_ -> E.encode $ unwrap >$<
        ( E.record
            { txOutRefId: E.value :: _ TxId
            , txOutRefIdx: E.value :: _ BigInt
            }
        )
    ) x

instance DecodeAeson TxOutRef where
  decodeAeson = defer \_ -> D.decode $
    ( TxOutRef <$> D.record "TxOutRef"
        { txOutRefId: D.value :: _ TxId
        , txOutRefIdx: D.value :: _ BigInt
        }
    )

derive instance Generic TxOutRef _

derive instance Newtype TxOutRef _

instance
  HasPlutusSchema TxOutRef
    ( "TxOutRef"
        :=
          ( "txOutRefId" := I TxId
              :+ "txOutRefIdx"
              := I BigInt
              :+ PNil
          )
        @@ (Z)
        :+ PNil
    )

instance ToData TxOutRef where
  toData x = genericToData x

instance FromData TxOutRef where
  fromData x = genericFromData x

--------------------------------------------------------------------------------

_TxOutRef :: Iso' TxOutRef { txOutRefId :: TxId, txOutRefIdx :: BigInt }
_TxOutRef = _Newtype
